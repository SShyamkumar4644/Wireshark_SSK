Let's start with the Application Layer. Application Layer is Layer 7, **and this is all about initiating contact with the network.** Usually, a user who would initiate, perhaps getting a webpage. The protocols that are used are HTTP, FTP, or SMTP. The protocol data unit at this layer is simply data. Nothing magical has happened, it's just simply data. And there's no addresses that are needed. The Presentation Layer will take the next step. It will format the data. It provides optional compression and encryption. And the protocol data unit at this point is simply data. Layer 5 is the Session Layer. This is all about initiating, maintaining, and tearing down a session. Again, the protocol data unit at this point is simply data. Now, when we go to the Transport Layer, this is where we start the encapsulation process. The Transport Layer is responsible for transporting data. Depending on how you need it transported, you might choose a connection-oriented protocol such as TCP or connectionless protocol such as UDP. The protocol data unit at this point is a segment. And at this point, we need a port address. We need the source and destination port address, which will logically associate with an appropriate application. Layer 3 is the Network Layer. This is all about the network. We provide addressing and routing. And when we talk about the different protocols that are in this layer, we know, of course, there is IP; and, of course, we also need ICMP; but let's take a look at that protocol that I put right in between Layer 3 and Layer 2, which is Address Resolution Protocol. Now, Address Resolution Protocol is a unique protocol and that there is no IP header. And that's because it's where it needs to be. There's no routing involved, it's simply resolving an IP address to a MAC address. The protocol data unit at this point is a packet, and the address is an IP address. Layer 2 or the Data Link Layer is all about proper frame formation. The protocol is Ethernet II, which is the most widely used protocol on the local area network. And the protocol data unit at this point is a frame. And the address is a MAC address. Now, it's all ready and packaged up, it's encapsulated with proper frame formation, and it has all the necessary addresses. It, then, is broken down into a stream of bits. So it's able to be transmitted on whatever media you need it to be transmitted on. There are no addresses and no protocols involved. Again, it's just sending it off on a stream of bits. So if you aren't already familiar with the OSI model, get a better understanding of each of the layers of the OSI model, what it does, the protocol data units, and the addressing. All in all, these skills will help you to analyze traffic better.

Let's start with the Application Layer. Application Layer is Layer 7, **and this is all about initiating contact with the network.** Usually, a user who would initiate, perhaps getting a webpage. The protocols that are used are HTTP, FTP, or SMTP. The protocol data unit at this layer is simply data. Nothing magical has happened, it's just simply data. And there's no addresses that are needed. The Presentation Layer will take the next step. It will format the data. It provides optional compression and encryption. And the protocol data unit at this point is simply data. Layer 5 is the Session Layer. This is all about initiating, maintaining, and tearing down a session. Again, the protocol data unit at this point is simply data. Now, when we go to the Transport Layer, this is where we start the encapsulation process. The Transport Layer is responsible for transporting data. Depending on how you need it transported, you might choose a connection-oriented protocol such as TCP or connectionless protocol such as UDP. The protocol data unit at this point is a segment. And at this point, we need a port address. We need the source and destination port address, which will logically associate with an appropriate application. Layer 3 is the Network Layer. This is all about the network. We provide addressing and routing. And when we talk about the different protocols that are in this layer, we know, of course, there is IP; and, of course, we also need ICMP; but let's take a look at that protocol that I put right in between Layer 3 and Layer 2, which is Address Resolution Protocol. Now, Address Resolution Protocol is a unique protocol and that there is no IP header. And that's because it's where it needs to be. There's no routing involved, it's simply resolving an IP address to a MAC address. The protocol data unit at this point is a packet, and the address is an IP address. Layer 2 or the Data Link Layer is all about proper frame formation. The protocol is Ethernet II, which is the most widely used protocol on the local area network. And the protocol data unit at this point is a frame. And the address is a MAC address. Now, it's all ready and packaged up, it's encapsulated with proper frame formation, and it has all the necessary addresses. It, then, is broken down into a stream of bits. So it's able to be transmitted on whatever media you need it to be transmitted on. There are no addresses and no protocols involved. Again, it's just sending it off on a stream of bits. So if you aren't already familiar with the OSI model, get a better understanding of each of the layers of the OSI model, what it does, the protocol data units, and the addressing. All in all, these skills will help you to analyze traffic better.


Now that you understand the different layers, let's build out a frame. Now when frame formation occurs and the encapsulation process takes place, we start out with a stump of data. Well, the data might be a web request. The next thing that happens is we create a segment and that would either be your TCP or UDP header. And within that segment, we have the source and destination port address. The next part of encapsulation is adding the IP header. Now at the network layer, it's called a packet. And within that, we have a source and destination IP address. The last part of this frame formation is the frame header. And within that, of course, we have the MAC address. And with a frame, not only is there a header, we also have a trailer. That is the frame check sequence. This is to provide error detection on a network by creating a cyclic redundancy check value that the network will check as it's traveling along on its way. Now, if we look at that frame formation and the encapsulation process, we can relate it to how it's presented to us in Wireshark. So take a look at this encapsulation and all the way at the top is, of course, your frame header. Frame is ethernet two and you see the source and destination MAC addresses within that frame header.](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3450bad1-4d0b-4251-af88-99c6252a388b/Untitled.png)

Now that you understand the different layers, let's build out a frame. Now when frame formation occurs and the encapsulation process takes place, we start out with a stump of data. Well, the data might be a web request. The next thing that happens is we create a segment and that would either be your TCP or UDP header. And within that segment, we have the source and destination port address. The next part of encapsulation is adding the IP header. Now at the network layer, it's called a packet. And within that, we have a source and destination IP address. The last part of this frame formation is the frame header. And within that, of course, we have the MAC address. And with a frame, not only is there a header, we also have a trailer. That is the frame check sequence. This is to provide error detection on a network by creating a cyclic redundancy check value that the network will check as it's traveling along on its way. Now, if we look at that frame formation and the encapsulation process, we can relate it to how it's presented to us in Wireshark. So take a look at this encapsulation and all the way at the top is, of course, your frame header. Frame is ethernet two and you see the source and destination MAC addresses within that frame header.

Now, if we look at that frame formation and the encapsulation process, we can relate it to how it's presented to us in Wireshark. So take a look at this encapsulation and all the way at the top is, of course, your frame header. Frame is ethernet two and you see the source and destination MAC addresses within that frame header. The next represents the network layer in the form of a packet. And there you see the IP header and of course, within that would be your source and destination IP address. Then we move to the transport layer where you see a segment and in this case, it's transmission control protocol. And there you have the source and destination ports. Tucked within that frame is the data. And here we see HTTP and it might be a web request. Keep in mind, not all frames have data **this is an example of a fully encapsulated frame,** just to show you how it relates in Wireshark to the OSI model. So it's important to understand the OSI model because the encapsulation process is evident in Wireshark and understanding each of the layers, the protocol data unit, and the addressing, will help you to analyze traffic better.

Now, if we look at that frame formation and the encapsulation process, we can relate it to how it's presented to us in Wireshark. So take a look at this encapsulation and all the way at the top is, of course, your frame header. Frame is ethernet two and you see the source and destination MAC addresses within that frame header. The next represents the network layer in the form of a packet. And there you see the IP header and of course, within that would be your source and destination IP address. Then we move to the transport layer where you see a segment and in this case, it's transmission control protocol. And there you have the source and destination ports. Tucked within that frame is the data. And here we see HTTP and it might be a web request. Keep in mind, not all frames have data **this is an example of a fully encapsulated frame,** just to show you how it relates in Wireshark to the OSI model. So it's important to understand the OSI model because the encapsulation process is evident in Wireshark and understanding each of the layers, the protocol data unit, and the addressing, will help you to analyze traffic better.

**Understanding the TCP-IP suite:**

1. The TCP/IP suite or internet suite is a set of protocols that allows us to communicate and exchange data on the network. The suite defines how data is packetized, addressed, transmitted, and routed. The key protocols are TCP, UDP, IP, and ICMP. We see the TCP/IP suite residing here at the network and transport layer. At the network layer, the main players are IP and ICMP. IP or the Internet Protocol is the network layer protocol used for routing the data from the source to the destination. IP is responsible for addressing and does not have any error reporting functions. For that, we use ICMP. This is used in addition to the Internet Protocol to carry error, routing and control messages, however, it does not exchange any data between systems. The transport layer provides data transport by using either TCP, which is a connection-oriented protocol or UDP, which is connectionless. You will hear that other protocols ride on top of the TCP/IP suite, and those would be protocols such as those in the application layer, HTTP, FTP, or SMTP. And we need to set, in our bindings, the ability to use TCP/IP, as pictured here in this graphic. The TCP/IP suite or internet suite is a set of protocols **that allows us to communicate and exchange data** on the network.

EXPLANING TRANSMISSION CONTROL PROTOCOL:(IMPORTANT)

Transmission control protocol resides at layer four or the transport layer of the OSI model. Transmission control protocol provides connection oriented transport. TCP begins with a three-way handshake and data is sequenced and acknowledged. TCP supports windowing and flow control so as not to overwhelm the host. Here's the TCP header.

And now we'll go into Wireshark and take a look at those field values. If you'd like to follow along, we'll go to cloudshark. I downloaded HTTP.cap and you can go to export and download file and bring it up in Wireshark. **(Download link: [https://www.cloudshark.org/captures/0012f52602a3](https://www.cloudshark.org/captures/0012f52602a3) )**Now, once in Wireshark, what I did was I'll show you here, it starts out with the three panels. I go to view and take off packet bites. I want a little more landscape. Now we'll bring this up and go to Frame 4. Let's just take a look at our encapsulation. Frame 4 is simply metadata about that frame. Here's the frame header, ethernet two, the network layer header IP, the transport layer header, TCP, and then the data HTTP. We're going to open up TCP. Now we can take a look, I'll float this on top, so you can refer to the TCP header. All right, first we see the source and destination port. The source port is 57678. Now sent from the client, that's simply saying when you come back, send the data to 57678. The destination port is 80, which is associated with HTTP. Here, we see stream index zero. There are no field value stream index, that's a value calculated by Wireshark. This helps you to keep track of the many different streams in Wireshark and if we were to look at conversations, we could go to stream index zero or stream 14 or whatever you'd like. Here, we see TCP segment length 134. Now, where did that value come from? Well, I'll scroll down here and I'll place my cursor on the HTTP header and here you see 134 bytes. Again, that's just a number calculated in Wireshark. Now here we see the sequence number one, and it's a relative sequence number. What that means it's in relationship to this stream, sequence number one, it's not the actual value. If it were, it's a large number, let's take a look. I'll right click. And I'll go to protocol preferences. Now here we can uncheck relative sequence numbers. And as you see, it's a large number. It's really hard to calculate values with that large number so we'll go back to relative sequence number by going to protocol preferences, and then we'll put relative sequence number back. For example, here it says next sequence number 135. Well, that's 134 plus one, and that's, what's calculated as what's coming next. Here, you see the acknowledgement number one and again, it's a relative acknowledgement number. And now here is the header length, 32 bytes. Normally a TCP header will be about 20 bytes. Now when we add options, that adds to the length. So let's take a look, I'll place my cursor up here at the TCP header and then down below, we see that the TCP header is 32 bytes. And we'll scroll up here and let's take a look at the flag section. Now, there's a lot going on with the flags. When you're ready to go a little more advanced, you can find out about all the flags and why we keep track of those is certainly your devices are monitoring what's happening during the conversation. The flags tell the story about what's going on at that point in time. Now some common ones that you'll see of course, is the syn flag and that's going to synchronize the sequence numbers. We see acknowledgement and that's of course acknowledging the data push. And the fin flag is when the conversation is over we exchange fin packets. And reset is when it set, it means I don't want to talk to you and the conversation has reset or closed. So a lot goes on with flags and it would be good to get familiar with those as you advance, because it tells a lot about the story and it is used for a number of different reasons. Right now we'll go to window size. Now window size, it says 46, but then there's a value here in brackets, it says calculated window size, that's a larger number. Well that's because the actual value is pretty small. And in the eighties, the window size of 46 would maybe be normal. But as you see, there's a scaling factor of 128, which gives us the true value of 5888. That's so the server knows about how much data I can send to the host without overwhelming the host. It will update if the value goes up or down, for example, if the host buffer were to get too full, the number would shrink. And as it processes the data, the number would then expand. Now we'll look at the check sum. It says unverified. Well, in a lot of cases, you'll find that we're not going to try to validate that check sum and here's why. Now take a look down below, there's a blue dot, cyan dot, and that's the expert system. Now, what is it saying is that it's just chats. Okay, so if this were to be calculated, this might be incorrect and I'll show you why. We'll go to protocol preferences. And here it says validate TCP checksum if possible, now I'll select that. And now you see it says it's incorrect and it should be this number. And as you see, there's a little note that says, TCP checksum offload, what happens is it offloads to the NIC card and it comes up in correct. Down below, you see the red dot and the expert system and that's saying that there's possibly something wrong with this stream, but there isn't. So we'll go back and check that and replace that with validate the TCP checksum if possible, and that'll correct that. But if checksum is important to use because it's going from source to destination. Many things could happen. The checksum in the TCP header, monitors for error detection, not correction. Now we see the urgent pointer and then down below, then what follows as you see over here, is options and data. Well now here you see the options and in this case, that options is 12 bytes. Now we know that it needs to be a multiple of four, so let's drop this down and see what's inside. Well, you see there's the timestamp option and that's 10 bites, but it has to be 12. So you see no ops, which are kind of placeholders so that it comes up to 12 bites. And then following that then, you see HTTP, which is the data. So that's the TCP header in Wireshark, **and we've gone over all of the field values** 
and hopefully you've got a little better understanding of TCP. 
